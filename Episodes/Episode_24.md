# Let's Talk ETC: Luke Wagner Of Mozilla On WASM, LLVM & Replacing The ECVM.
**Christian Seberino:**
in the world of block chains and
aetherium classic we have several
development groups now working as you
know simultaneously or you should know
on aetherium classic development and
regarding proposals for new innovations
I have a very special guest with me
today I have Luis hwagok scuse me Luke
Wagner of Mozilla he is a longtime
researcher engineer he's been there I
believe for seven years he's done
research he's been on the engineering
team so welcome Luke 



**Luke Wagner:**
thank you thank you
for having me 





**Christian Seberino:**
so I why don't you why
don't we start by you telling me a
little about yourself like first of all
how in the world do you have to be like
you know just this unbelievable stellar
programmer to get hired to be working on
something that's gonna affect you know
hundreds of millions of people or how
does that how'd you get involved 




**Luke Wagner:**
yeah
well I guess I feel like I just kind of
got lucky I did my master's research in
like compilers and vm's and C++ type of
things and at A&M; with dr. Stross trip
and so after we after those my first job
after college was just I applied to
Mozilla cuz I use Firefox and wanted to
work on something that I used myself and
I really liked that it was open-source
and that's about all I knew about the
web I but uh yeah I was just just a good
luck I suppose 




**Christian Seberino:**
so that's right yes so
you went to school there and you c++




**Luke Wagner:**
 right
yeah dr. Strauss true and 




**Christian Seberino:**
then
immediately after you graduated you got
hired by Mozilla 



**Luke Wagner:**
that's right 



**Christian Seberino:**
okay and
what tell me like and tell me some of
the initiatives I don't know how much
you could say you're not safe but what's
the cool stuff that



**Luke Wagner:**
 when I joined we
were just I guess the team already had
been deploying the first our first chips
in Firefox after several attempts before
this one actually shipped called trace
monkey it was a tracing jet and also it
wasn't the best approach we went on did
then I got to start on our next approach
which was called Jaeger monkey a very
different style JIT and then after that
another chick called iron monkey which
is still in Firefox today and really
fast and and I was I got to be part of
that was called the games program which
is a program to see can we make games
run fast on the web so that people don't
have to use plugins and if we make you
know the web fast enough for games will
allow a whole bunch of other kind of
practical things that have been had the
way paved for them and and and that that
consumed a lot of my time and the games
program then led to azzam j/s which is
this subset of JavaScript where we ask
the kind of research question of how
what's the theoretical limit of how fast
can we make this compiled JavaScript
code like it's generated by some
compiler how fast we make it run and how
fast can we make it load and then that
azzam jess success led to everyone being
excited about doing something even
better which is web assembly which is
where I'm today 





**Christian Seberino:**
okay now in my in my
mind when I think of Mozilla so first of
all it's a cool company because they
work on a lot of free software or open
source software and a lot of a lot of
open source initiatives are not very
well funded I there's a few right RedHat
the enterprise district corporation
whatever they do well we know what they
do they make a distribution and help
companies but then Mozilla is like for
all I know my tea the the second biggest
open-source contributor well there's
Google of course but I really think of
Mozilla as one of the top open source
free software contributors right well
funded there hmm to do all kinds of cool
stuff and so are they gonna know so
they're gonna continue
how am I gonna continue doing more cool
stuff continuing research and oh 






**Luke Wagner:**
yeah
yeah we have great plans you know it's
all it's all about the web and you know
our mission is to you know make sure the
internet stays is an open global public
resource accessible to everyone so you
know still plenty of work left to do
along that mission 




**Christian Seberino:**
Google pays a large
sum of money to be the default search
engine in the Firefox box is that where
the majority of the funding comes from





**Luke Wagner:**
you know it's not really my area of
expertise what I precisely at what money
comes from where but I think it's no
longer the case that Google's the
default a search provider and that's
that's Yahoo now 




**Christian Seberino:**
that was so compelling
that that was that made you guys able to
get funding to do all this cool pay for
that 


**Luke Wagner:**
yeah yeah basically 



**Christian Seberino:**
yeah


**Luke Wagner:**
 me too 


**Christian Seberino:**
so
all right so the topic I wanted to
invite you on the show to talk about
especially was web assembly so you've
said you've worked on that so why don't
you introduce us and the audience to web
assembly and why people should be
interested in it 




**Luke Wagner:**
oh sure yeah well you
know basically what web assembly is it's
a standard that defines a format for
binary code so this is the format that
goes over the wirings consumed by a web
sembly engine including the one that
runs in a browser and the standard says
you know exactly how you encode a
program in this in a binary format and
then exactly what it means to run that
program and you know the the design of
web assembly is such that it's it's a
really low level instruction set that's
meant to be compiled from some
high-level language that you would write
especially you know right now we're
focusing on C C++ but lots of other
languages to follow in the future
and and it's a it's a compact formats
there so you know you don't spend a lot
of time downloading it even when it's
not compressed but even smaller when it
is compressed and it's designed to run
efficient
or at least not require a bunch of
backflips to be able to get it to run
fast in an engine and unless I guess the
last high-level point I would say it's
probably relevant here to the listener
is its defined to be independent of both
the web and javascript so although that
was our primary use case in our leading
use case the course Beck is is abstracts
over the host of who's running it and so
you can run in lots of different
contexts 





**Christian Seberino:**
especially interesting so it's
not it's not tied to the web even though
it's it's 





**Luke Wagner:**
as web in its name number
there



**Christian Seberino:**
 but in principle people just all
the places that people use like the Java
Virtual Machine they could in principle
use web assembly 





**Luke Wagner:**
right yeah that's it's
it could be embed the virtual machine
could be or a web assembly virtual
machine could run in lots of places were
and we're starting to see that now as
people are finding new places where web
assembly the its properties make sense





**Christian Seberino:**
okay just explain to our listeners so
the here in classic virtual machine and
the etherium virtual machine there's
discussions about replacing the existing
virtual machine with alternatives that
can arguably be better for smart
contracts some ideas that are being
banded around our LLVM and then web
assembly and that's that's the reason
why you might want to be interested or
look into web assembly if you're
interested in block chains and aetherium
classic now what is the status of web
assembly currently 





**Luke Wagner:**
so the current status
is that we have a informally a draft
spec that has been kind of given the
thumbs up by a lot of people involving
for the four main browsers and it's
starting to ship currently in release of
Firefox and Chrome it has been since
March and in the pre-release channels of
Apple or Safari and an edge so to be
released you know on both their desktop
and mobile browsers so it's of by the
end of the year more or less it should
be in all the major browsers so we
basically have our kind of initial
version nailed down and we're now
working on getting the actual spec
moving that through the w3c process we
just formed a working group which is
kind of the official group that will
kind of make the standard a real
standard and then at the same time the
community group which is kind of the
very open group that's based around
github that just anyone can join is
starting to talk about the next waves of
features to that will be implemented
next in browsers




**Christian Seberino:**
 okay and so it's gonna
be in browsers before the spec is
completed 



**Luke Wagner:**
well yeah it's it's
interesting there's this definite
synergy between implementing and
specifying where you know your
experience implementing tends to point
out things that are impossible or under
specified or counterintuitive in the
spec and then you know of course the
spec you know determines what goes into
the browser so we definitely did
implementation and specification at the
same time but before anyone shipped
anything we had kind of a quiet period
we called the browser preview where it
was disabled by default but behind a
preference that people could start to
experiment with and we use that as a
period to to let things stabilize and
make sure we all agreed so so it had it
in a pretty stable state even though the
final specification hasn't kind of gone
through the full formal process 



**Christian Seberino:**
okay and
I know you guys have a lot of big
players mistaken Microsoft Google
Mozilla of course do you anticipate that
they're the they will there'll be a lot
of kind of standstill 




**Luke Wagner:**
oh well
fortunately we that's the that's the
hard part we already got through and and
I think we avoided a lot of what often
you can see in you know the sort of big
dramatic fights in standards by a we had
a we involved everyone from the very
beginning of the design process so
high-level constraints you know that
might have caused a standstill were just
simply incorporated in the design from
the beginning and and basically everyone
showed really good faith in the whole
process everyone's really eager to see
the thing finished every was eager to
see it not take you know a decade and so
we kind of avoided a lot of that sort of
stuff so we what we have now is is is is
a stable v1 that we all agree on
so we 





**Christian Seberino:**
yeah okay so I it sounds like
they're cooperating to move the process
forward but Google had their own
initiative right the Native Client and
so there was competing initiatives and
they everybody just decided to bury the
hatchet and 






**Luke Wagner:**
well well you could follow
interestingly a lot of Native Client
people contributed a lot of valuable
stuff to the webassembly efforts so some
sense they you know you could think of
there's some joining of forces here
although the design is of webassembly is
quite different than the Native Client
in some ways but if you also you look
recently there's a public blog post from
Google team saying kind of I that well
you know web assemblies you know the
future and long live web assembly and
all that so yeah so a lot of so I guess
we've you know resolved any of that sort
of conflicts in the past 





**Christian Seberino:**
now I have my
own reasons why I wanted kind of to hear
your what what makes you passionate of
what gets you up in the morning thinking
about




**Luke Wagner:**
 well what excites me I guess is
just as a general point making the web
platform capable enough that you don't
have this decision of oh I can go native
and be you know be fast but I'm a button
part of usually a walled garden or
there's you know
I have to install on their security
issues or on the other hand there's the
web but it's slow it's safe and it has
all this grazer experience but it's slow
I want to avoid that slowness downside
so that way there can be no reason not
to use the web so more stuff can you
know move on to the web and the web can
just be this one uniting platform so a
key part of that you know there's lots
of pieces of that puzzle a lot of it's
about you know the API is an i/o and how
you reach out and touch stuff but a core
part of it was how do I run code on the
CPU and you know for 20 years that was
that was JavaScript and it could go
really fast and it could go really slow
and it was hard to predict even if you
really knew performance even if you're a
JavaScript engine author
so what web assembly tries to do is just
add predictable good performance as a
feature that you can use if you need it




**Christian Seberino:**
ok so you're interested in making the
web faster and why for the audience can
you explain why the current situation
with the JavaScript engine why couldn't
that be faster or fast enough can you
kind of elaborate on that well 




**Luke Wagner:**
yeah for
plenty of uses it actually is fast
enough so and that's that's why for so
long
there was only JavaScript despite 20
years of people proposing alternatives
is JavaScript is you know decently fast
and a lot of times the bottlenecks just
not in your code it's in you know
layouts or it's in the network or
something else but there is this set of
use cases where you know if you want to
make you know an online cabinet er if
you want to do Photoshop on the web if
you want to do a video game gonna do
video decoding or if you want to do some
sort of custom encryption thing or just
all sorts of cases where you do spend a
lot of time just churning through code
and for that one you know the the
central hardness is that it's just hard
to predictably get good performance out
of JavaScript because to get good
performance you need the engine to make
to jump over a whole bunch of hurdles it
needs to see a lot of things and those
things are based on heuristics and
heuristics are designed to do well a lot
of the time but you know it's it's hard
to get them right on all the cases or
even know what the engines looking for
and so you have a lot of high-level
advice out there like you know try to
have
Koby monomorphic try not to do this
trying to that but it's it's just really
hard without a lot of clear feedback to
know when you're hitting that sweet spot
and then lastly if you have just a ton
of code if you have you know megabytes
and megabytes of JavaScript just the
time to parse all that JavaScript and
then warm it up through the interpreter
and then through the baseline compiler
and then the optimizing compiler and
then maintain all the metadata needed to
know to optimize just all of that can
add up to a lot of time so it can take a
while to warm up large amounts of code




**Christian Seberino:**
so I'm not a compiler expert like you
but if I was trying to simplify because
I'm a teacher I try to make things
simple so what you're saying is with web
assembly you have compiled code and it's
the compiler that gives you these
advantages right with JavaScript
you're throwing source code at the
browser and it has to do the best it can
with source code whereas you you're so
you're so much farther ahead when you
have compiled code



**Luke Wagner:**
 yeah that's that's a
good way to say it too we've we're
taking advantage of a big pipeline that
happens before the browser even gets the
code oh well there's still a good amount
of work that has to happen within the
browser because for example it has to do
various optimization passes that
specialize this target independent code
to be target specific so web assembly
doesn't know how many registers you have
on your machine and other things like
that so there is some decent amount of
work that has to happen but it's just a
whole lot less then when you start with
the source language




**Christian Seberino:**
 okay and the same
way that compilers get more and more
sophisticated for different platforms
presumably
in time right the webassembly compilers
would become phenomenal really a lot of
incredible optimizations to make code
run faster



**Luke Wagner:**
 yeah there is a real
possibility there because unlike native
code we can actually recompile you know
we can do stuff like profiling see what
your code does at runtime we can say oh
you have a the newest you know x86 chip
which is this feature we'll use that new
feed
instead of the you know the the feature
that's on every chip so there there are
some opportunities for us to do really
fast things 




**Christian Seberino:**
okay so it's it's faster
than source code but it sounds like what
you're saying is because we don't know
that the native platform it's in the
middle right so it's still not going to
be as fast as native code because the
web assembly doesn't know the native the
details of the underlying actual
hardware





**Luke Wagner:**
 well there's two dimensions of
performance here one of this load time
and one is throughput like once they're
all loaded and on on load time yeah we
have to do more work because we have to
compile this binary code that's staying
you know platform-independent into
machine code so there's a load time
angle and that we've actually done a lot
of things to make load time get faster
like we compile while while it's
downloading we compile in parallel we
have a first-tier compiler we have to do
a lot of things there but the other
dimension is throughput which is once
once it is running and that one you know
we are seeing right now it really
depends on the workload but you know
often will be 20% slower than native
which is pretty pretty good comparing to
where we started with with javascript
and that that difference is is shrinking
over time and really what hold us back
the only thing that kind of gets in our
way is we at all times have to be safe
and portable and that that's there's a
lot we can do within those confines but
that that will always be this this kind
of gap that you know that native code
doesn't have to be safe 





**Christian Seberino:**
I'm thinking I
watched this video years ago they maybe
you're familiar with it it was it was
about a smj yes but he was the speaker
was talking about you know thinking
about decades in the future where we're
all running like you said these huge
applications 



**Luke Wagner:**
oh I know what you're
talking about now 






**Christian Seberino:**
what surprised me
about that one of the things that stood
out was he said you know hypothetically
in the future 30 years down the road we
have where the we're a smas or now I
guess webassembly takes over the world
that you could run a Linux program from
2017
and it would run faster in a SMAS you go
over that part 






**Luke Wagner:**
yeah this is this the
birth and death of JavaScript yes by
Gary Bernhard 




**Christian Seberino:**
adopts it makes these
super awesome compilers that it's not
just going to be portable but it could
be even better than what we have now for




**Luke Wagner:**
well um you know it's I get in the few
I'm not sure how we would generally get
much faster than native code I mean
processors will get faster so I guess a
future processor might run the code
faster in today's processors I Duke I
can't see that people could build whole
environments that abstract you know that
are virtual machines for today's like
Linux and you you actually see you know
people have written not very fast but
whole Linux emulators in JavaScript
there's there's a pretty famous one and
so it does make sense to be able to host
like whole-hog you know full linux
desktops now there is an aspect which is
it's it's there's a lot of benefits to
using the stuff that's built into the
browser like using the built in text
layouts text rendering and all the what
the browser does with HTML and CSS that
there's a whole lot of aggregate value
there that it's it would take a lot of
code to emulate all that so that's user
when people ask like they hear about
webOS and they're like oh good I'll
render my own HTML I'll just you know do
my own thing and you know that's
possible but it's it's not necessarily a
good idea because you know the Dom
brings with it a lot of accessibility a
lot of interoperability a lot of
integration with a lot of tools and yeah
so so people can do that but I'm not
sure if that will become a common thing



**Christian Seberino:**
21:52----22:10




**Luke Wagner:**
yeah and you hear about this you hear
about like IBM's OS 390 or 60 you know
it's
that you know that was defined you know
40 years ago and it's still running
today on radically different hardware so
I you probably will see emulation stuff
like that where you just have old
programs that just absolutely have to
run and yeah you can emulate them in a
as soon as you have a Turing complete
language you can emulate them and so we
might you might see that and if you look
at like the internet you know
archive.org the what's called the
internet history but they have a bunch
of console emulators so you can play a
bunch of old video games now for free
it's pretty funny and using they're
using an emulator that was written in C
or C++ compiled to azzam jeaious so in
some parts that that that's becoming
reality and has been for a




**Christian Seberino:**
 year or so
yeah you could take these huge game
engines written in C C++ today right and
compile them to azzam j/s and run run
these huge 



**Luke Wagner:**
yeah and there'll be you know
tens of millions of lines of C++ and
instead of having to rewrite into
JavaScript there will do just basically
compile it




**Christian Seberino:**
so web assembly is a compelling target
that's portable that's going to get
faster every year now why do you think
that this effort will succeed where
other efforts have have not taken over
the world
is there something that makes you
confident about web assembly




**Luke Wagner:**
 yeah well
some of it is that you know it's some
degree we've already crossed an
important threshold where it's you know
once it's shipping in multiple browsers
on the web at in release it that's it's
it's sort of that you know the the
boulder is rolling so in some sense it's
it we cannot we already can feel pretty
good about this and I think what allowed
us to get to that point because a lot of
these things in the past have have not
run on on more than one or maybe two
browsers and the problem is just getting
a lot of different parties with a lot of
different goals and opinions on board
and then that's where where when we
started this thing we had as MJS which
ran in all browsers because it's just
JavaScript there was not a question of
supporting it was
how well did you run it and so that put
everyone into the mindset of we care we
can see the use cases we can see people
shipping the stuff on live sites and
then we can feel like this azzam jest
basically works but we can improve on in
a few obvious ways we can make it
smaller we can make it binary format we
can make it we can fix some of the
performance words and that put everyone
kind of on the same page to start with
and then when everyone was involved from
the beginning such that this wasn't just
why wasn't I consulted sort of there was
none of that you know that that just put
everyone lined up everyone up to to make
a standard that actually shipped 



**Christian Seberino:**
25:09-25:19




**Luke Wagner:**
okay
yeah I mean there also I can point out
you know links some some technical
limitations of other approaches to that
website was able to learn from and an
address but I mean the political ones
are as bigger bigger 





**Christian Seberino:**
now here's here's
my experience with virtual machines and
tell me your thoughts on this so in the
90s that was when I heard about Java and
their virtual machine and the idea of
running the same code on different
platforms and that was compelling and
then and people started even
implementing other languages on the Java
Virtual Machine which was cool and then
I remember going to a Python conference
and there was talked about implementing
Python not just in JVM the jabra
trishing but also then and what was new
then the the.net the common language
runtime and I remember one guy getting
all excited saying no no you don't
understand Microsoft has learned from a
lot of supposed mistakes in the JVM it's
over take over the world and then and
then now in the last couple years I've
heard about
I keep hearing what LLVM pop up on
different articles and mention here and
there and and some people think that's
going to take over the world
and then I it's even now replacing
like a new compiler in a lot of
situations people say it's it's better
for the using that for the C compiler
there there native or the compiler that
targets their works with LLVM so I mean
from from my experience it's just it
seems like every couple years there's a
new and improved write virtual machine
that's going to take over the world so
i-i've what would you say to people that
think that you know in five years
there's going to be some other




**Luke Wagner:**
 well no
doubt in in five years there will be
something new although maybe maybe
people's appetite for new virtual
machines has been wedded by the extreme
success of JVM and dotnet in their
respective areas so but probably there
that there will always be something new
there all those previous things though
haven't been in web browsers and I think
that's what's responsible for the
success of JavaScript the language and
the fact that it's in all the browsers
and and now with the web's not even just
in browsers you know it's in it's in
WebKit WebKit views inside of you know
apps it's in it's in lots of other
places and so the fact that webassembly
is actually a web standard and in
browsers I think will give it the same
sort of advantage that JavaScript had
and so being a you know when Nets had
Silverlight which was a plug-in and the
JVM had a Java plug-in but uh but you
know now the web's working to turn off
plugins altogether so that that kind of
whole and in the browser to inject kind
of a random new virtual machine is kind
of being closed up so at least on the
web I I don't think there will be
another VM you know kind of of the Java
or.net style and that will uh that will
emerge and and one other kind of
important thing is that web VM is
designed very much to be just another
language inside of the existing VM of
the web browser so there's this kind of
low-level notion of there's only one VM
here there's just two different types of
code and they're sharing compiler
backends the thing that generates the
machine code they're sharing a garbage
collector they're sharing
internationalization they're sharing all
the
API surface so what that means is the
amount of duplication from having two
things in the browser is pretty minimal
it's really only you know there's a
separate parser for JavaScript and a
Dakota for wasm and there's some a few
bits of runtime support that are
different but by and large these are
just two different small slightly
different paths within the same big
virtual machine so it's different in
respect than if we just plugged in the
dotnet that in that case there would be
two different whole virtual machines the
the JavaScript one and a very separate
dotnet one and what this allow web
simply to do for example is point to
JavaScript objects and have JavaScript
point to web assembly objects in the
future when web simply has GC
integration



**Christian Seberino:**
 so yes so from a practical
standpoint you're saying that web
assembly their virtual machine is is it
has reasons to to argue for its choice
for the browser that because that one
big one being that it works with
JavaScript right now but just to be just
to be fair just out of curiosity
well not fair maybe that's if if that
wasn't a concern if you were just saying
oh if you just decided today you know
what I'm gonna decide which virtual
machine should take over the world and
you are comparing all the ones I
mentioned just on their intrinsic
technological merits
can you say something because I'm sure
there's people out there that they they
have an emotional connection to those
something about why it's better not just
because it talks with JavaScript so well
but why this technology itself is better
well 




**Luke Wagner:**
yeah I guess some of it could go to
the fact that you know the goal of Java
and.net is is kind of different it's
inherently I think these were designed
more for both server side and installed
client applications and so and that's
that's kind of a different environment
than webassembly which is this very you
know first of its it's very networked so
you're sending over the wire the program
frequently and it's part of this very
important cold startup time so that the
binary size matters a huge deal and this
our top speed matters a huge deal and I
think it's not that this you know Java
and.net are really have terrible things
that first start up speed but I think
web sembly being completely designed
around startup is gives it some
advantages in terms of how the format
was designed I mean at the same time net
is a hugely capable PM I've just been
learning recently because the the dotnet
folks came to a web assembly community
group meeting and where they're talking
about you know publicly and otherwise
how they can generate web assembly as
like as a back-end for it for dotnet
code and just learning about all the
capabilities they have and there's they
just have a bunch of things for
interoperating with native unsafe C++
code that just simply can never be part
of web assembly because eNOS we can't
allow on safety and kind of raw native
code on the web in the same way so in
stairs different goals and use cases
being served by these different VMs




**Christian Seberino:**
 okay
okay now I I mean I'll be honest I'm
lazy I don't want to learn lots of
different VMs so I'm I'm kind of hoping
you'll make the case why web assemble
you'll take over the world




**Luke Wagner:**
well well maybe it doesn't the VM
technology you could think of it as a
processor architecture it's it's a thing
you compile from a source language so
maybe what you're hoping is your
preferred language will become
ubiquitous such that you can use it for
the server side and for your client side
and all the bits in between like I hear
great things about c-sharp and if the
dotnet folks you know are able to carry
forward then you know maybe one day
you'll be able to write c-sharp for all
the things if that's what you're
interested in and similarly on the other
direction the typescript is becoming
immensely popular and pushing its way
into you know into the server so and
we've talked to them about with some
tweaks to typescript how a typescript
could generate in some cases web
assembly and then you could use
typescript everywhere if that's what
you're into so for P it makes total
sense to not to to say I'd like to
program in what we in one language with
one set of libraries and I think that
that that is a realistic future 



**Christian Seberino:**
okay now
is it necessary for me to be wanting one
to take over the world because you could
take the bytecode from all these
different virtual machines and you know
the compiler convert one to the other




**Luke Wagner:**
yeah basically I would save maybe from
the source language and sometimes the
byte codes are they've already lost some
amount of information about the source
language sometimes but if we're talking
about source languages that could you
know it does make sense that they might
yeah target all the different you know
both net VM and and the webassembly




**Christian Seberino:**
okay I was I was reading something about
source Maps so a lot of people when they
think of bytecode decompiling it's the
corresponding source code but apparently
there was some documentation that was
saying no no it's not that bad




**Luke Wagner:**
 oh sure
yeah there's this feature that's already
but you know people have been compiling
JavaScript from other languages for you
know a decade now and of course you want
to open up and debug it and you don't
want to see this scrambled minified
javascript you want to see your source
code so they invented this format
debugging format called source maps
which just says how the JavaScript code
you generated maps back to the source
files and so what we did is we kind of
made the minimal tweaks to that so it
applies just as well to web assembly we
said those numbers instead of being line
members of JavaScript those are bytecode
offsets in Azzam a bytecode file so so
today actually in Firefox nightly you
can open up you can compile from M
scripting from C++ to Azzam and set a
flag saying I want source maps and then
you can debug your C++ in the browser



**Christian Seberino:**
well I can abstract syntax tree but
you're saying you could make different
language 





**Luke Wagner:**
yeah it's sort of a map it kind
of doesn't care what your source
language was it's really just
establishing establishing a mapping from
your bytecode offsets or your JavaScript
offsets that is in what you generated
back to your source language and then
when the debugger wants to show the
source it says ok what source file
contains this generated function I'm in
and
then what line number and that source
file should I go - given that I'm here
in the generated code



**Christian Seberino:**
 now you're it
sounds like you're saying that you can
get a much cleaner nicer source code
representation that corresponds to a
binary than you can with other virtual
machines is that correct



**Luke Wagner:**
 well I don't
know what if a similar source map types
things apply to the other virtual
machines I have not an expert in them I
in theory they could do the same thing
but it is you can't see your identical
source files with with azzam now 




**Christian Seberino:**
I mean
36:16-36:28



**Luke Wagner:**
well yeah you that the JavaScript it D
compiles to probably would look not like
the same thing you wrote it I what I
died I assumed variable names would have
been stripped at least a fuse if you
shrunk that class file so of course
you'll have synthesized variable names
and things like that
now with wasm you have of course there's
nothing forcing you to ship the source
map and it's actually a large file so if
developer doesn't generate source maps
and force we they're separable so you
can sit down just the dot wasum that
doesn't have any source maps and then
only load the source map on demand if
the user actually opens the debugger but
if they're no source map is provided
then what we generate will be it'll look
kind of like assembly it'll it'll be
kind of raw 




**Christian Seberino:**
the reason you could do this
awesome source code is because you have
this additional data structure called a
source map and then if somebody wanted
to first wanted to obfuscate their code
then they would not ship the source map



**Luke Wagner:**
exactly 




**Christian Seberino:**
okay now I was when I was
researching web assembly for this
interview one thing that's what struck
me was they I read somewhere that it's
the the bytecode is is basically a
entered abstract syntax tree it's not
really a register based machine code can
you comment on that 




**Luke Wagner:**
yeah you bet so
there's there's a sense in which that's
still true and there's a sense in which
it changed in one of the last iterations
of the spec that we went through so if
you say what does it mean to run a web
selling program today it is actually a
stack based machine you start with you
know when you call a function you start
it starts with an empty stack and then
as things evaluate they push and pop
from the stack and it's a tight stack so
in a very very restricted stack so you
always know kind of statically what's on
the stack no matter how you got there so
in some sense it is a stack machine but
in another sense the way we define if
you look at the spec the way it's
described what we say is there a module
that the code that you send over the
wire it's an abstract syntax tree that's
encoded in in binary and when you're
executing the stack machine it's that's
the those op codes are part of an
abstract syntax tree so in some sense
it's it depends precisely what you mean
by abstract syntax tree it's okay you
can kind of describe anything with an
abstract syntax tree it's even if it it
happens to be byte code you can say well
a module is composed of a list of
sections and then one section of the
code section and it contains a list of
functions and a function contains a list
of off codes you know and that's a very
simple abstract syntax tree which still
contains a stack machine in it so it's a
sort of a choice of definitions 






**Christian Seberino:**
would
you say that the the representation of
web assembly is a higher level than the
JVM representation and these other
virtual machines 



**Luke Wagner:**
uh actually I wouldn't
say that it's probably about similar
yeah I got in some sense it's lower
level in JVM and dotnet you have these
built-in notions of classes as so part
of the source language type system is
built into the into what you send over
the wire and in wasm our goal is to try
to not care about
source languages and just give you the
lowest level building blocks that you
generates into so in some sense it's
lower level 





**Christian Seberino:**
and and so as you know
aetherium as I said very minute classic
there's discussion about using
webassembly
now and then people have also some
people like the LLVM what are what are
your comments on
webassembly versus LLVM 





**Luke Wagner:**
well yeah this
was definitely a question we encountered
early on because it was also a question
when comparing the webassembly approach
to the portable Native Client approach
which used LVM IRS bit code as there
with some encoding but as there
distributable format and a at a high
level I think the biggest difference is
that L VMs IR and bit code are
inherently compiler IR it's it's meant
to be an intermediate format on your way
compiling from the source language all
the way down to machine code and as such
it's entirely you know specialized to
what LVM needs it for which is not to be
a portable standard that is has
completely well specified semantic stats
is gonna do the same thing everywhere so
if you look at LV Mir it has a lot of
undefined behavior that's inherently
built-in where you say if you do this
you shouldn't but if you do all bets are
off like you know and the missiles could
fire you know people always joke about
what undefined behavior could mean so
there's undefined behavior and some of
the behavior is sort of not completely
rigorously specified and if you compare
that to webassembly we tried to maximize
defined anis as far as we possibly could
and if you look you know we have a list
of first we have no undefined behavior
things always have a list of specific
things that can happen never anything
just well one of a set of things and the
only cases where we have that are
running out of resources because you
overflow the stack or allocate too much
memory which is inherently platform
dependent and the other one is the bit
bitwise encoding
of not a number the floating-point value
not a number can vary slightly simply
because different chips do different
things and we it would be waste lower if
we try to normalize and so that's other
than those two tiny things it's
completely specified and completely
deterministic which is really important
because when you change us like when you
move your x86 binary between different
computers
different processors between Intel and
AMD you don't expect it to behave
differently other than maybe running
faster slower
similarly you shouldn't expect your
wisdom to break on one and so we that's
you know was a very strong reason why we
tried to squash out all sources of non
determinism 





**Christian Seberino:**
I believe the way that
Native Client the way Google tried to
solve this problem was they you only use
the subset of LLVM and right and they
basically like a special they worked off
of LLVM and





**Luke Wagner:**
 yeah you can subset it I
think certain amounts of undefined
behavior still remain and and another
thing I didn't mention was it's there's
this cut when you have a spec and we've
had this from the foreign web standards
you don't want there to be a single
implementation that kind of defines the
spec where it's due at LVM does and want
there to be multiple independent
implementations and and and that was a
problem if I recall for you know web
sequel or whatever is called that was
basically do its sequel itdoes was well
there's only one of rotation its sequel
i and and so that would that would be a
problem is is how its defined and yeah
other things are like that are kind of
really technical is is how the stack is
treated in in web assembly you can be
the only pointers you can have her into
this big contiguous array of bytes that
are completely well-defined its this is
memory you allocate nothing else goes
into it whatever bytes are there exactly
the bytes you put there and all the
stack memory is off-limits you the
compiler can generate code that loads
and stores from the stack and this is
what it does to put
like when you do a call and it pushes
the return address or when you have when
you do register allocation and you need
to spill stuff to the stack it goes on
the stack and because that is kept away
from the web assembly code speaking at
it that cuts off a major important
source of non of undefined behavior
where you could say well what happens if
I store and I clobber stuff on the stack
what happens if I replace the return
address with some random number like
that jump send it like my own code and
all sorts of stuff like that so that's
kind of very baked into the model of
Eliam and I and and and very baked out
of the model of web assembly so there's
I think subtle technical things like
that that are differences that involve
portability 




**Christian Seberino:**
one argument that to support
what you're doing and to support people
in blockchain space using the web
assembly virtual machine was that you
could leverage so much momentum write
anything on the web of course is used by
hundreds of millions of people and so
the the attention and care being put to
the tools to support it is gonna be so
much better than any anything else and
so it's almost like you you know why
fight that momentum 




**Luke Wagner:**
yeah yeah I think
that's a really good argument to use web
technologies is a capture momentum 





**Christian Seberino:**
so
like if I was to make my own little
virtual machine and had a small
community and I was trying to make
developer tools IDE I bees right for my
little VM I would run into issues
where's right there's gonna be so much
awesome stuff that Google Microsoft
Apple and Mozilla are gonna create for
web assembly why would you want to you
know reinvent the wheel all 





**Luke Wagner:**
right yeah
that makes sense




**Christian Seberino:**
okay now the as we wind down the last
big topic that a lot that's on a lot of
people's mind so I don't know I I know
you've spoken to some people in the
etherium community and you know a little
bit about block chains but
one concern with software in this space
is because we're dealing with large
quantities of money is they having the
software have you know basically doing
what you think it's going to do what you
expect it to do and you've already
spoken to that by saying that you try to
eliminate undefined behavior
now people even talk about going so far
as to mathematically you know verify
they want things to be math provably
secure mathematically secure and this is
this is actually not a new idea right
people have been developing software for
think about like air traffic controllers
robotic surgeons space travel so does
can you speak to that need that desire
to have





**Luke Wagner:**
 yeah well that makes total sense
that people would want that because yeah
just as a as just an observer right it's
I can see the importance when you have
these hacks that go in just because
there's a bug in the code and given that
I assume these these contracts are are a
little smaller than like you know 10
million lines you know codes it's gonna
be a lot more amenable to mechanically
very verified proof then than otherwise
so that makes total sense and I think
this is an area where website has a lot
to offer because one key thing is this
spec is is written in already in a
mathematical formalism that is very
directly you can mechanize this and some
groups have already so there's you know
proofs that have been I think
mechanically verified of the soundness
of web assemblies type system and this
just shows that you can turn web
assembly into something that
mathematically verifiable so if you now
have a source language that compiles to
webassembly you could prove that you
know the the source language to
webassembly transformation maintains
this the meaning of the source program
and then on top of that you could prove
that in terms of the source language
that it does what it says it's going to
do or what that whatever you want that
contract to do so I think for such a
system you really want your bedrock you
know the the instruction set which is
web
to have a completely formal description
and that's what webassembly has and if
you go back to your last question about
compared to LVM I think it would be a
big novel work to create such a thing
for LVM and whereas Elvia I mean
webassembly has that today and it's and
it's it's pretty it's pretty simple as
far as formalisms go




**Christian Seberino:**
 okay now just to
play devil's advocate what about if
somebody says well the Java Virtual
Machine or dotnet I don't know if
they've formally specified to the level
that people want but




**Luke Wagner:**
 yeah so we have a
peel a peel di paper out this just this
year about web assembly and it makes the
point that the web assembly formal
semantics you can fit in one page and
and with Java and.net I think there have
only been approximations of the full
semantics just because they're these
these VMs do so much and and these these
approximations are hundreds of pages and
still not capturing the fullness of it
so it's it's really a different order of
magnitude of mathematical complexity
here if you want to capture the entire
platform now if you subset it maybe you
could pare it down but web assembly is
really simple by design in this case and
in the paper it was claimed like gives
because we you know designs that this
system with the formal the formal rules
in it in mind the whole time 



**Christian Seberino:**
I think is
gonna be music to a lot of people's ears





**Luke Wagner:**
yeah anyone should head over to web
assembly org and then click spec might
just be slash back I forget but web
assimilated org and then look at spec
it's it's a UK you can see the the live
draft and it's all hyperlinks and and it
should look like if used to any sort of
formal specs in the kind of formal
languages community it should look very
familiar 



**Christian Seberino:**
okay great so you've you've
made a compelling case you've introduced
people to web assembly and you've shown
why it's it has good potential for the
future and for more market adoption is
there
like do you have any thoughts on the
next couple years what should people
expect to see 




**Luke Wagner:**
so the big thing which
we've kind of more officially kicked off
just in our last in-person community
group meeting was the GC integration
feature which is let's let right now web
assembly has access to this big array of
bytes that it can load and store from
but that excludes a whole lot of what
you want to talk to or point at in you
know in a web browser which is all the
Dom objects all of the API objects like
file objects and blobs and sockets and
other things so this is what this
proposal would be is to a give web
assembly first-class references to all
these things and be and that means
integrate with the garbage collector
that's already built into the to the
browser and what this would mean as web
assembly could point to dom things they
could point back to web assembly things
and in the garbage collector could clean
up these cycles and that's something
that's just not possible today with web
assembly you end up having to stick
things into arrays that keeps them alive
until you explicitly remove them which
means the garbage collector can't room
cycles so this is like a huge feature
and it'll take a lot of work but that's
the big exciting thing and it'll mean
that to generate web assembly you don't
have to use a low-level language like
C++ you could use like c-sharp and other
languages 



**Christian Seberino:**
now and then just to repeat
something you said at the beginning of
our talk correct me if I'm wrong but so
you said by the end of the year the all
the major browsers are gonna support web
assembly so this is not vaporware or
something that's not there's just being
talked about that we have to wait a long
time to see in production but people if
people can could start using this and
checking it out right now yeah and they






**Luke Wagner:**
yeah I totally encourage them to it's
they can try it out and yeah things will
run in Firefox and Chrome today and in
Safari nege pretty soon 





**Christian Seberino:**
okay well so
it's it sounds pretty impressive for a
virtual machine for a standard that
takes over the world in all fairness
maybe I should ask you what would not be
something that you would want to that
you would will not want to use the web
the standard platform for





**Luke Wagner:**
 well I guess
one answer is trying to to compile
JavaScript to have assembly it's a it's
a thing people keep asking about it's
like well and and it's inherently you
have a JavaScript engine already in the
browser so that's that's gonna run your
JavaScript the best so that I guess that
would be one and and similarly if I
think Java scripts a pretty pretty good
dynamic program a dynamic scripting
language so if what you want is a
dynamic scripting language I would think
you know using JavaScript would be a
good idea and and webassembly would be
what you kind of reserved for your
low-level languages like C++ or in the
future your your typed high-level
languages like C sharp so I'd be one
example right 



**Christian Seberino:**
54:11----54:27





**Luke Wagner:**
and and it's um and you
know it's a good scripting language and
you look at a lot of large applications
they ultimately all of them involve they
tend to grow a scripting language just
to script stuff and I would hope that
people continue to use JavaScript for
that and they are scripting you know it
could be JavaScript scripting
webassembly so you're using both of them
for their strengths in a single
application and I think that's what
we're going to see more of so I guess a
broader statement they're not an ongoing
B to kill JavaScript 





**Christian Seberino:**
so I think we've
touched on a lot of the bases for people
that and we've we've talked about how it
could be a compelling alternative to the
existing aetherium classic aetherium
virtual machine and why it will probably
succeed where a lot of other standard
efforts have failed that I'm is there
anything else that you want to say
before we we close 



**Luke Wagner:**
no great set of
questions thank you 


**Christian Seberino:**
okay all right so
just
talking with me and I'm sure a lot of
people are gonna appreciate this
interview what's my pleasure thanks
[Music]
if you are passionate about anything
related to etherium classic
